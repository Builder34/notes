线程安全总结：

1.局部变量中的基本数据类型(8种)永远是线程安全的。
2.局部变量中的对象类型只要不会被其他线程访问到，也是线程安全的。
3.一个对象实例被多个线程同时访问时，他的成员变量就可能是线程不安全的。

Java内存模型：
一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。
一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。
一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。
一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。
静态成员变量跟随着类定义一起也存放在堆上。

存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。
如果两个线程同时调用同一个对象上的同一个方法，
它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。



为什么使用多线程？
http://www.cnblogs.com/xrq730/p/4850883.html
http://blog.csdn.net/zdwzzu2006/article/details/2252516
http://www.ibm.com/developerworks/cn/education/java/j-threads/j-threads.html

线程间通信、回调：
http://blog.whyun.com/posts//
http://lavasoft.blog.51cto.com/62575/98796/


你有事去隔壁寝室找同学，发现人不在，你怎么办呢？
方法1，每隔几分钟再去趟隔壁寝室，看人在不
方法2，拜托与他同寝室的人，看到他回来时叫一下你
前者是轮询，后者是回调。

那你说，我直接在隔壁寝室等到同学回来可以吗？
可以啊，只不过这样原本你可以省下时间做其他事，现在必须浪费在等待上了。把原来的非阻塞的异步调用变成了阻塞的同步调用。
JavaScript的回调是在异步调用场景下使用的，使用回调性能好于轮询。
